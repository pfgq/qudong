#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/sched.h>
#include <linux/pid.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <asm/ptrace.h>

/* ================= 固定参数 ================= */
#define HWHOOK_TARGET_PID   11255
#define HWHOOK_BP_ADDR      0x5a5b485880UL
#define HWHOOK_NEW_X0       0x7FD48D94B4UL

/* ================= 全局状态 ================= */
static struct perf_event *g_hwbp;
static struct task_struct *g_task;

/* 原始断点属性 */
static struct perf_event_attr g_orig_attr;
/* 临时“下一条指令”断点 */
static struct perf_event_attr g_next_attr;

/* 是否处于第二次命中 */
static bool g_on_next_hit = false;

/* ================= HWBP 回调 ================= */
static void hwhook_handler(struct perf_event *bp,
                           struct perf_sample_data *data,
                           struct pt_regs *regs)
{
    unsigned long pc;
    unsigned long old_x0;

    if (!regs)
        return;

    pc = regs->pc;
    old_x0 = regs->regs[0];

    if (!g_on_next_hit) {
        /* ===== 第一次命中 ===== */
        printk(KERN_INFO
               "[hwhook] HIT1 pid=%d pc=0x%lx x0=0x%lx -> 0x%lx\n",
               HWHOOK_TARGET_PID, pc, old_x0, HWHOOK_NEW_X0);

        /* ===== 核心：强制覆盖 x0 ===== */
        regs->regs[0] = HWHOOK_NEW_X0;

        /*
         * 双命中处理：
         * 将断点临时移动到下一条指令
         * ARM64 指令长度固定 4 字节
         */
        memcpy(&g_next_attr, &g_orig_attr,
               sizeof(struct perf_event_attr));
        g_next_attr.bp_addr = pc + 4;
        g_next_attr.disabled = 0;

        if (!modify_user_hw_breakpoint(bp, &g_next_attr)) {
            g_on_next_hit = true;
        } else {
            printk(KERN_ERR
                   "[hwhook] modify_user_hw_breakpoint(next) failed\n");
        }
    } else {
        /* ===== 第二次命中 ===== */
        printk(KERN_INFO
               "[hwhook] HIT2 pc=0x%lx restore original bp\n",
               pc);

        modify_user_hw_breakpoint(bp, &g_orig_attr);
        g_on_next_hit = false;
    }
}

/* ================= 安装硬件断点 ================= */
static int hwhook_install_bp(void)
{
    struct pid *pid_struct;

    pid_struct = find_get_pid(HWHOOK_TARGET_PID);
    if (!pid_struct) {
        printk(KERN_ERR "[hwhook] find_get_pid failed\n");
        return -ESRCH;
    }

    g_task = pid_task(pid_struct, PIDTYPE_PID);
    if (!g_task) {
        printk(KERN_ERR "[hwhook] pid_task failed\n");
        return -ESRCH;
    }

    hw_breakpoint_init(&g_orig_attr);
    g_orig_attr.bp_addr = HWHOOK_BP_ADDR;
    g_orig_attr.bp_len  = HW_BREAKPOINT_LEN_4;
    g_orig_attr.bp_type = HW_BREAKPOINT_X; /* 执行断点 */
    g_orig_attr.disabled = 0;

    g_hwbp = register_user_hw_breakpoint(&g_orig_attr,
                                         hwhook_handler,
                                         NULL,
                                         g_task);
    if (IS_ERR(g_hwbp)) {
        printk(KERN_ERR
               "[hwhook] register_user_hw_breakpoint failed\n");
        return PTR_ERR(g_hwbp);
    }

    printk(KERN_INFO
           "[hwhook] HWBP installed pid=%d addr=0x%lx\n",
           HWHOOK_TARGET_PID, HWHOOK_BP_ADDR);

    return 0;
}

/* ================= 卸载硬件断点 ================= */
static void hwhook_uninstall_bp(void)
{
    if (g_hwbp) {
        unregister_hw_breakpoint(g_hwbp);
        g_hwbp = NULL;
        printk(KERN_INFO "[hwhook] HWBP uninstalled\n");
    }
}

/* ================= 模块入口 / 退出 ================= */
static int __init hwhook_init(void)
{
    printk(KERN_INFO "[hwhook] module init\n");
    return hwhook_install_bp();
}

static void __exit hwhook_exit(void)
{
    hwhook_uninstall_bp();
    printk(KERN_INFO "[hwhook] module exit\n");
}

module_init(hwhook_init);
module_exit(hwhook_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("hwhook");
MODULE_DESCRIPTION("ARM64 user HW breakpoint hook: force set x0");
